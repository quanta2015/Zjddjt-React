{"ast":null,"code":"const toString = Object.prototype.toString;\n\nconst isArray = Array.isArray || function (val) {\n  return toString.call(val) === '[object Array]';\n};\n\nconst isValidParamValue = val => {\n  const t = typeof val; // If the type of val is null, undefined, number, string, boolean, return TRUE.\n\n  return val === null || t !== 'object' && t !== 'function';\n};\n\nconst endsWith = (str, suffix) => {\n  const index = str.length - suffix.length;\n  return index >= 0 && str.indexOf(suffix, index) === index;\n};\n\nconst encode = encodeURIComponent;\n\nconst decode = function (s) {\n  try {\n    return decodeURIComponent(s.replace(/\\+/g, ' '));\n  } catch (err) {\n    return s;\n  }\n};\n\nexport const param = function (o, serializeArray = true, sep = '&', eq = '=') {\n  const buf = [];\n\n  for (let key in o) {\n    const val = o[key];\n    key = encode(key); // val is valid non-array value\n\n    if (isValidParamValue(val)) {\n      buf.push(key);\n\n      if (val !== undefined) {\n        buf.push(eq, encode(val + ''));\n      }\n\n      buf.push(sep);\n    } // val is not empty array\n    else if (isArray(val) && val.length) {\n        for (let i = 0; i < val.length; ++i) {\n          const v = val[i];\n\n          if (isValidParamValue(v)) {\n            // ?aParam[]=value1&aParam[]=value2&aParam[]=value3\n            buf.push(key, serializeArray ? encode('[]') : '');\n\n            if (v !== undefined) {\n              buf.push(eq, encode(v + ''));\n            }\n\n            buf.push(sep);\n          }\n        }\n      } // ignore other cases, including empty array, Function, RegExp, Date etc.\n\n  }\n\n  buf.pop();\n  return buf.join('');\n};\n/**\n * query字符串转为对象\n */\n\nexport const unparam = function (str, sep, eq) {\n  str = str + '';\n  sep = sep || '&';\n  eq = eq || '=';\n  const ret = {};\n  const pairs = str.split(sep);\n  const length = pairs.length;\n  let key, val;\n\n  if (!str) {\n    return ret;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const eqIndex = pairs[i].indexOf(eq);\n\n    if (eqIndex === -1) {\n      // 没有=\n      key = decode(pairs[i]);\n      val = undefined;\n    } else {\n      // remember to decode key!\n      key = decode(pairs[i].substring(0, eqIndex));\n      val = decode(pairs[i].substring(eqIndex + 1));\n\n      if (endsWith(key, '[]')) {\n        key = key.substring(0, key.length - 2);\n      }\n    }\n\n    if (key in ret) {\n      if (isArray(ret[key])) {\n        ret[key].push(val);\n      } else {\n        ret[key] = [ret[key], val];\n      }\n    } else {\n      ret[key] = val;\n    }\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["/Users/manqingchen/Documents/Project/Zjddjt/system/src/util/param.js"],"names":["toString","Object","prototype","isArray","Array","val","call","isValidParamValue","t","endsWith","str","suffix","index","length","indexOf","encode","encodeURIComponent","decode","s","decodeURIComponent","replace","err","param","o","serializeArray","sep","eq","buf","key","push","undefined","i","v","pop","join","unparam","ret","pairs","split","eqIndex","substring"],"mappings":"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","sourcesContent":["const toString = Object.prototype.toString\nconst isArray =\n  Array.isArray ||\n  function(val) {\n    return toString.call(val) === '[object Array]'\n  }\n\nconst isValidParamValue = val => {\n  const t = typeof val\n  // If the type of val is null, undefined, number, string, boolean, return TRUE.\n  return val === null || (t !== 'object' && t !== 'function')\n}\nconst endsWith = (str, suffix) => {\n  const index = str.length - suffix.length\n  return index >= 0 && str.indexOf(suffix, index) === index\n}\n\nconst encode = encodeURIComponent\n\nconst decode = function(s) {\n  try {\n    return decodeURIComponent(s.replace(/\\+/g, ' '))\n  } catch (err) {\n    return s\n  }\n}\n\nexport const param = function(o, serializeArray = true, sep = '&', eq = '=') {\n  const buf = []\n\n  for (let key in o) {\n    const val = o[key]\n    key = encode(key)\n\n    // val is valid non-array value\n    if (isValidParamValue(val)) {\n      buf.push(key)\n      if (val !== undefined) {\n        buf.push(eq, encode(val + ''))\n      }\n      buf.push(sep)\n    }\n\n    // val is not empty array\n    else if (isArray(val) && val.length) {\n      for (let i = 0; i < val.length; ++i) {\n        const v = val[i]\n        if (isValidParamValue(v)) {\n          // ?aParam[]=value1&aParam[]=value2&aParam[]=value3\n          buf.push(key, serializeArray ? encode('[]') : '')\n          if (v !== undefined) {\n            buf.push(eq, encode(v + ''))\n          }\n          buf.push(sep)\n        }\n      }\n    }\n    // ignore other cases, including empty array, Function, RegExp, Date etc.\n  }\n\n  buf.pop()\n  return buf.join('')\n}\n\n/**\n * query字符串转为对象\n */\nexport const unparam = function(str, sep, eq) {\n  str = str + ''\n  sep = sep || '&'\n  eq = eq || '='\n\n  const ret = {}\n  const pairs = str.split(sep)\n  const length = pairs.length\n  let key, val\n\n  if (!str) {\n    return ret\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const eqIndex = pairs[i].indexOf(eq)\n    if (eqIndex === -1) {\n      // 没有=\n      key = decode(pairs[i])\n      val = undefined\n    } else {\n      // remember to decode key!\n      key = decode(pairs[i].substring(0, eqIndex))\n      val = decode(pairs[i].substring(eqIndex + 1))\n\n      if (endsWith(key, '[]')) {\n        key = key.substring(0, key.length - 2)\n      }\n    }\n    if (key in ret) {\n      if (isArray(ret[key])) {\n        ret[key].push(val)\n      } else {\n        ret[key] = [ret[key], val]\n      }\n    } else {\n      ret[key] = val\n    }\n  }\n  return ret\n}\n"]},"metadata":{},"sourceType":"module"}